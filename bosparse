#!/usr/bin/env bash

# bosparse - a bash script to parse parameters for bash scripts
# author: blovecob
# version: 0.1.1
# platform: bash 4.4+
# usage:
#   - source bosparse
#     bosparse [option parameters] -- [positional parameters]
#   - eval $(bosparse [option -arameters] -- [positional parameters])
#   - json=$(bosparse ~j [option parameters] -- [positional parameters])
#
#
set -euo pipefail

function definitions() {
	local -n BOSPARSE_CONFIGS_ref=$1
	local -n BOSPARSE_CONST_ref=$2
	local -n PSETS_ref=$3
	local -n PSET_ALIAS_ref=$4
	local -n PRIORS_ref=$5
	local -n LIDS_ref=$6
	local -n RESERVED_SYMBOLS_ref=$7
	local -n EXCEPTIONS_ref=$8
	local -n EXIT_MSG_ref=$9

	# constants
	BOSPARSE_CONST_ref=(
		["NO_PFILTER"]="no-para-filter"
		["PFILTER_ID"]="PARA-FILTER"
		["PPBB"]="Parameter Parsed by BosParse"
	)

	# BOSPARSE_PARAMETER_NAME
	# running and output
	local run="run_mode"
	local j="output_as_json"

	# PFILTER
	local pf="pfilter"
	local pf_id="pfilter_id"
	local amf="all_matching_filter"

	# array for results
	local oan="opara_array_name"
	local ban="bool_array_name"
	local san="string_array_name"
	local pan="ppara_array_name"

	# parsing-aid sympbols
	local prior="prior_lid"
	local plid="pset_lid"
	local olid="opara_lid"
	local tt="trailing_tag_true"
	local tf="trailing_tag_false"
	local td="trailing_tag_default"
	local zs="zn_sep"
	local os="oa_sep"

	# runtime display control
	local q="quiet"
	local s="standard"
	local e="extra"
	local d="debug"
	local t="trace"

	CONFIG_PARAS_ref=(
		"${run}"
		"${j}"
		"${pf}"
		"${pf_id}"
		"${oan}"
		"${ban}"
		"${san}"
		"${pan}"
		"${prior}"
		"${plid}"
		"${olid}"
		"${tt}"
		"${tf}"
		"${td}"
		"${zs}"
		"${os}"
		"${q}"
		"${s}"
		"${e}"
		"${d}"
		"${t}"
	)

	# bosparse default configs
	BOSPARSE_CONFIGS_ref=(
		# running mode
		["${run}"]="auto" # ~run/mode, maybe "source", "eval" or "capture"
		["${j}"]=false    # ~j/~json, output  to stdout as json

		["${pf}"]="${BOSPARSE_CONST_ref[NO_PFILTER]}"    # identifying ~pf not supplied
		["${pf_id}"]="${BOSPARSE_CONST_ref[PFILTER_ID]}" # identifier for valid PFILTER
		["${amf}"]=false                                 # all parameters should match entries in PFILTER

		# parse results
		["${oan}"]=BP_OParas  # ~oan,  name of array to store OParas
		["${ban}"]=BP_Bools   # ~ban,  name of array to store Bool-OParas
		["${san}"]=BP_Strings # ~san,  name of array to store String-OParas
		["${pan}"]=BP_PParas  # ~pan,  name of array to store PParas

		# runtime display control
		["${q}"]=false # ~q output level, 0
		["${s}"]=true  # ~s output level, 1(default)
		["${e}"]=false # ~e output level, 2
		["${d}"]=false # ~d output level, 3
		["${t}"]=false # ~t output level, 4

		# Prior PSets
		# Parsing-aid symbols
		["${prior}"]='~~~' # ~~~prior,  leading id sighn for prior- psets and seps
		["${plid}"]='~'    # ~~~plid,   leading id sign for setting-parameters
		["${olid}"]='-'    # ~~~olid,   leading id sign for user-parameters

		# seps
		["${zs}"]='--' # ~~~zs, separator between VAR_ZONE and PP_ZONE
		["${os}"]='='  # ~~~os, separator between para-names and their args

		# trailing tags
		["${tt}"]='+'  # ~~~tt, tag character for 'true'
		["${tf}"]='-'  # ~~~tf, tag character for 'false'
		["${td}"]=true # ~~~td, defaut tag value(when tag omitted)
	)

	# parsing result arrays
	local o_array=${BOSPARSE_CONFIGS_ref["${oan}"]}
	local b_array=${BOSPARSE_CONFIGS_ref["${ban}"]}
	local s_array=${BOSPARSE_CONFIGS_ref["${san}"]}
	local p_array=${BOSPARSE_CONFIGS_ref["${pan}"]}
	declare -gA "${o_array}" "${b_array}" "${s_array}"
	declare -ga "${p_array}"

	LIDS_ref=(
		["prior"]="${BOSPARSE_CONFIGS_ref[${prior}]}"
		["plid"]="${BOSPARSE_CONFIGS_ref[${plid}]}"
		["olid"]="${BOSPARSE_CONFIGS_ref[${olid}]}"
	)

	PSETS_ref=(
		["run"]="${run}:enum:auto|source|eval|capture"
		["j"]="${j}:bool"

		["pf"]="${pf}:string"
		["pf_id"]="${pf_id}:string"
		["amf"]="${amf}:bool"

		["oan"]="${oan}:string"
		["ban"]="${ban}:string"
		["san"]="${san}:string"
		["pan"]="${pan}:string"

		["q"]="${q}:bool"
		["s"]="${s}:bool"
		["e"]="${e}:bool"
		["d"]="${d}:bool"
		["t"]="${t}:bool"
	)

	PSET_ALIAS_ref=(
		["json"]="j"
		["mode"]="run"
		["quiet"]="q"
		["standard"]="s"
		["extra"]="e"
		["debug"]="d"
		["track"]="q"
	)
	# Prior PSets config structure:
	#   field1: config name of entries in CONFIGS | string
	#	field2: prior type | a letter
	#	        may be boolean(b), string(s), character(c) or enum(e)
	#   field3: for type-c: symbol length | integer, use default(1) if not set
	#           for type-e: emum | enum values separated by '|'
	#   field4: meg name | string(mutual-exclusion value group)
	#           for configs not permitted to share same value
	# all four fields needed even if it's empty
	PRIORS_ref=(
		["prior"]="${prior}:resym:3:"
		["plid"]="${plid}:resym::glid"
		["olid"]="${olid}:resym::glid"
		["zs"]="${zs}:resym:2:"
		["os"]="${os}:resym::"
		["tt"]="${tt}:resym::gtagv"
		["tf"]="${tf}:resym::gtagv"
		["td"]="${td}:bool::"
	)

	# reserve symbols for LIDs and SEPs
	RESERVED_SYMBOLS_ref=(
		'~'
		'-'
		'='
		'_'
		'+'
		'&'
		'%'
		'@'
	)

	# exceptions for bash variable naming convention, replacing hyphens with underscores
	EXCEPTIONS_ref=(['-']="_")

	pros_tag=""
	pros_tag2=""
	EXIT_MSG_ref=(
		["0"]="Parsing succeeded."
		["1"]="Parsing failed."
		["2"]="No parameter supplied."
		["3"]="Only one ZONE_SEP '--' required."

		["23"]="Prior parse error."
		["24"]="A solitary ARG '\${pros_tag}' found."
		["25"]="Invalid PSet parameter: '\${pros_tag}'"
		["26"]="Parameter name '\${pros_tag}' invalid, it should be a valid shell variable name."
		["31"]="Invalid Prior name: '\${pros_tag}'"
		["32"]="PSet '\${pros_tag}' mismatch the length."
		["33"]="The parameter name '\${pros_tag}' contains invalid character(s)."
		["34"]="Prior settings conflict between '\${pros_tag}'"
		["35"]="Invalid PSet '\${pros_tag}' setting: ARG should be '\${pros_tag2}'"
		["36"]="Prameter '\${pros_tag}' in liga '\${pros_tag2}' not valid."
		["37"]="Same settings in meg '\${pros_tag}' members: '\${pros_tag2}'"
		["38"]="value of '\${pros_tag}' should not be empty."
		["39"]="PSet '\${pros_tag}' type '\${pros_tag2}' invalid"
		["40"]="Invalid PFILTER enum entry '\${pros_tag}': ARG should be '\${pros_tag2}'"
		["41"]="Parameter \${pros_tag}': type '\${pros_tag2}' not satisfied by PARA_FILTER."
		["42"]="Para-type defined in PFILTER '\${pros_tag2}' for '\${pros_tag}' not support."
		["43"]="Invalid PFILTER entry: alias '\${pros_tag}' requires a target '\${pros_tag2}' but not exist"
		["44"]="Parameter '~amf' requires 'PFILTER' but not supplied."
		["45"]="PSet '~amf' requires all supplied-parameters be defined in 'PFLILTER' but '\${pros_tag}' didn't."
		["46"]="Parameter '\${pros_tag}' defined in 'PFILTER' without default value and not supplied."
		["47"]="To output JSON, 'jq' required but not available ."
		["48"]="Invalid PFILTER enum entry '\${pros_tag}': missing enum values."
		["49"]="Invalid PFILTER, \${pros_tag}"
		["50"]="Invalid PFILTER setting, only one alias allowed for one target, but '\${pros_tag}' got '\${pros_tag2}'"
		["51"]="Invalid PFILTER alias entry '\${pros_tag}': chaining alias not support."
	)
}
# Primitives --------------------------------------------------
#
# check if the parameter is a array key
function is_array_key() {
	local key=$1
	local -n arr_ref=${2:-} # array might not available
	local k
	for k in "${!arr_ref[@]}"; do
		[[ ${k} != "${key}" ]] || return 0
	done
	return 1
}

# chck if a string is a array member
function in_array() {
	local str=$1
	local -n arr_ref=${2:-} # array might not available
	local mem
	for mem in "${arr_ref[@]}"; do
		[[ ${mem} != "${str}" ]] || return 0
	done
	return 1
}

# calculate the max length of members of an array
# usage max_lengh_array_members arrayref max_lenthref "$extra_len"
function max_length_array_members() {
	local -n arr="$1" l_max="$2"
	local extra="${3:-0}" # optional

	l_max=$(($(
		for member in "${arr[@]}"; do
			echo "${member}"
		done | wc -L
	) + extra))
}

function show_array() {
	local -n target_arr=$1
	local separator=${2:--}
	local key lmax=0
	declare -a keys_array
	# build keys array
	keys_array=("${!target_arr[@]}")

	max_length_array_members keys_array lmax 2
	for key in "${!target_arr[@]}"; do
		printf "%${lmax}s %s %s \n" "${key}" "${separator}" "${target_arr[${key}]}" >&2
	done
}

# function: bp_msg
# feature:
#   show msg by msg_level
#   a nective msg_level number means show msgs in one-line(no CR)
function bp_msg() {

	local msg_level=${1:-0} title=${2:-} content=${3:-}

	# nothing to show
	[[ "${verbose}" == 0 || -z "${verbose}" ]] && return 0

	if [[ "${msg_level}" -lt 0 ]]; then
		in_one_line=true
		msg_level=$((0 - msg_level))
	fi

	# local IFS=$'\n'
	if [[ "${verbose}" -ge "${msg_level}" ]]; then
		if [[ "${in_one_line:-false}" == true ]]; then
			echo -e "\e[33m${title}\e[0;2m ${content}\e[0m" >&2
		else
			[[ -n "${title}" ]] && echo -e "\e[33m${title}\e[0m" >&2
			[[ -n "${content}" ]] && echo -e "\e[2m${content}\e[0m" >&2
		fi
	fi
	return 0
}

# Expand simple ${varname} templates in messages for safe printing.
function template_expand() {
	local template=$1
	# Replace known placeholders safely. Add more as needed.
	template=${template//\$\{pros_tag\}/"${pros_tag}"}
	template=${template//\$\{pros_tag2\}/"${pros_tag2}"}
	printf '%s' "${template}"
}

# exit with a specific exit code and a revelant message
function exit_with_msg() {
	local exit_code=$1
	local additional_msg=${2:-}
	local last_command=${3:-}
	local msg

	if [[ "${verbose:-0}" -gt 0 ]]; then
		msg="${EXIT_MSG[${exit_code}]}"

		# expand any template variables (e.g., ${pros_tag}) in message safely
		local _msg_expanded
		_msg_expanded=$(template_expand "$msg")
		printf '\e[33merror:\e[0m %s\n' "$_msg_expanded" >&2
		if [[ -n "${additional_msg}" ]]; then
			_msg_expanded=$(template_expand "$additional_msg")
			printf '\e[2m        %s\e[0m\n' "${_msg_expanded}" >&2
		fi
		if [[ -n "${last_command}" ]]; then
			# Run the additional command in a subshell to avoid unsafe eval in current shell
			bash -c -- "${last_command}" >&2
		fi
	fi
	exit "${exit_code}"
}

# bash variable naming convention
# hyphens are permitted if they are not at the very beginning
# replacing hyphens by underscores
# trailing-tag should be removed in advance, or will be interpreted as underscore
function validate_shell_variable_name() {
	local -n var_name_ref=$1
	return_on_error=${2:-false}

	[[ "${var_name_ref}" =~ ^[a-zA-Z_][a-zA-Z0-9_-]*$ ]] || {
		if [[ ${return_on_error} == true ]]; then
			return 1
		else
			pros_tag="${var_name_ref}"
			exit_with_msg 26
		fi
	}
	# replace exceptions
	for orig in "${!EXCEPTIONS[@]}"; do
		var_name_ref=${var_name_ref//"${orig}"/"${EXCEPTIONS[${orig}]}"}
	done
	return 0
}

# Helper functions --------------------------------------------
#
# test if a string contains leading-id
#   if lid specified, test with it
#   or try all lids
function with_lid() {
	local para=$1 lid=${2:-}
	if [[ -n ${lid} ]]; then
		[[ ${para} == "${lid}" ]] && return 0
		[[ ${para} =~ ^${lid}[^${lid:0:1}].*$ ]] && return 0
		return 1
	else
		# try all lids
		for lid in "${LIDS[@]}"; do
			[[ ${para} == ${lid}* ]] && return 0
		done
		return 1
	fi
}

# check if a string consist of members of a RESYMS
function in_resyms() {
	local sample=$1
	local mb

	for mb in "${RESYMS[@]}"; do
		mb=${mb//[\'\"]/}                           # remove quotes
		[[ "${sample}" =~ ^[${mb}]+$ ]] && return 0 # matched
	done
	return 1 # match failed
}

# turn output settings to verbose
function update_verbose() {
	# trace > debug > extra > standard > quiet

	[[ ${CONFIGS["quiet"]} == true ]] && {
		__QUIET=true
		verbose=0
	}
	[[ ${CONFIGS["standard"]} == true ]] && {
		__STANDARD=true
		verbose=1
	}
	[[ ${CONFIGS["extra"]} == true ]] && {
		CONFIGS["standard"]=true
		__STANDARD=true
		__EXTRA=true
		verbose=2
	}
	[[ ${CONFIGS["debug"]} == true ]] && {
		CONFIGS["standard"]=true
		CONFIGS["extra"]=true
		__STANDARD=true
		__EXTRA=true
		__DEBUG=true
		verbose=3
	}
	[[ ${CONFIGS["trace"]} == true ]] && {
		CONFIGS["standard"]=true
		CONFIGS["extra"]=true
		CONFIGS["debug"]=true
		__STANDARD=true
		__EXTRA=true
		__TRACE=true
		__DEBUG=true
		verbose=4
	}
	[[ -n ${verbose:-1} ]] || {
		verbose=1
		__STANDARD=true
	}
	return 0
}

# check possible trailing tag for a para-name
function parse_bool_tag() {
	local para=$1
	local tag=${para: -1}

	case "${tag}" in
	"${TAG_TRUE}") echo true ;;
	"${TAG_FALSE}") echo false ;;
	*) echo "${TAG_DEFAULT}" ;;
	esac
}

function pset_alias_key() {
	local alias=$1
	if is_array_key "${alias}" alias_used; then
		echo "${alias_used[${alias}]}"
	else
		echo "${alias}"
	fi
	return 0
}

# validate a PSet parameter name, exit with error message if test failed
function validate_pset_name() {
	local -n pname_ref=$1
	local -n psets=$2

	# check aliase
	is_array_key "${pname_ref}" PALIAS && {
		alias_used[${PALIAS[${pname_ref}]}]="${pname_ref}"
		pname_ref="${PALIAS[${pname_ref}]}"
	}
	# echo "pname: $pname_ref"
	pros_tag="${pname_ref}"
	is_array_key "${pname_ref}" psets || exit_with_msg 25
	return 0
}

# check if a supplied PSet match the type defined in PSETS
function match_pset_type() {
	local para=$1 type_ref=$2
	local type_defined

	type_defined="${PSETS[${para}]#*:}"   # remove config name
	type_defined="${type_defined%%:*}"    # remove length/enum and meg name if exist
	type_defined=${type_defined//[\"\']/} # remove quotes if exist
	[[ ${type_ref} == "${type_defined}" ]] || {
		pros_tag="${para}"
		pros_tag2="${type_ref}"
		echo pros_tag2: ${pros_tag2}
		exit_with_msg 39
	}
}

# validate a PSet value with its type and length/enum
function validate_pset_arg() {
	local para_name=$1 para_type=$3 lid=$5
	local -n para_arg=$2 para_sets=$4

	# echo "$para_name | $para_arg | $para_type | ${para_sets[*]}"
	local pset_schema=${para_sets[${para_name}]}
	# local pset_value=${pset_schema%%:*}    # extract value
	pset_schema=${pset_schema#*:}      # remove value
	local pset_type=${pset_schema%%:*} # extract type
	pset_schema=${pset_schema#*:}      # remove type
	local pset_data=${pset_schema%%:*} # extract data
	[[ -n ${pset_data} || ${pset_type} != 'resym' ]] || pset_data=1

	[[ "${para_type}" == "${pset_type}" || ${pset_type} == 'enum' ]] || {
		case "${pset_type}" in
		bool) pros_tag2="true/false" ;;
		string) pros_tag2="a string" ;;
		resym) pros_tag2="in RESYMS" ;;
		enum) pros_tag2="an enum value of ${pset_data}" ;;
		*) ;;
		esac
		pros_tag="${para_name}"
		pros_tag2="${para_type}"
		exit_with_msg 39
	}

	pset_property_check "${lid}" "${para_name}" "${pset_type}" para_arg "${pset_data}"
}

# parse a liga, validate para-name, passing back result
# usable for all ligas
function parse_liga_para() {
	local liga=$1
	local -n paras_ref=$2
	local -n settings_ref=$3

	local tag para_len start para_name

	tag=$(parse_bool_tag "${liga}")

	liga=${liga%"${TAG_TRUE}"}      # remove true tag if exist
	liga=${liga%"${TAG_FALSE}"}     # remove false tag if exist
	para_len=${liga%%[^[:digit:]]*} # extract para length
	liga=${liga#"${para_len}"}      # pure liga name left
	[[ -n "${para_len}" ]] || para_len=1

	for ((start = 0; start < ${#liga}; start += para_len)); do
		para_name="${liga:${start}:${para_len}}"
		is_array_key "${para_name}" paras_ref || {
			pros_tag="${para_name}"
			pros_tag2="${liga}"
			exit_with_msg 36
		}
		settings_ref["${paras_ref[${para_name}]%%:*}"]=${tag}
	done
}

# check if a pset para value matching type and length
# exit with error message if test failed
function pset_property_check() {
	local lid=$1 pname=$2 ptype=$3 pdata=$5
	local -n parg=$4
	local pset_alias

	# echo "$lid | ${pname} | ${ptype} | ${parg} | ${pdata}"
	# validate value
	case ${ptype} in
	bool) # check if value is true/false
		[[ ${parg} == true || ${parg} == false ]] || {
			pros_tag="${pname}"
			pros_tag2="a boolean value(true/false)"
			exit_with_msg 35
		}
		;;
	enum) # enum, check if value in enums
		# split enum string safely into array
		local IFS='|'
		read -ra enum <<<"${pdata}"
		if ! in_array "${parg}" enum; then
			pset_alias=$(pset_alias_key "${pname}")
			pros_tag="${lid}${pset_alias}=${parg}"
			pros_tag2="${pdata//\|/\/}"
			exit_with_msg 35
		fi
		;;
	resym) # check if in resyms, length
		pset_alias=$(pset_alias_key "${pname}")
		pros_tag="${lid}${pset_alias}=${parg}"
		pros_tag2="in RESYMS(${RESYMS[*]})"
		# prior settings should be in RESYMS
		in_resyms "${parg}" || exit_with_msg 35
		[[ "${pdata}" == "${#parg}" ]] || exit_with_msg 32
		;;
	string) # string, should be a valid shell variable name after replacing hyphens with underscores
		pros_tag="~${pname}"
		validate_shell_variable_name pname || exit_with_msg 33
		# should not be empty
		[[ -n "${parg}" ]] || exit_with_msg 38
		;;
	*) ;; # skipped for others
	esac
	bp_msg -3 "    - properties valid:" "'${pname}'"
	return 0
}

# get all priors in a meg
function prior_meg_members() {
	local gname=$1
	local -n members=$2
	local gn

	for pri in "${!PRIORS[@]}"; do
		gn=${PRIORS["${pri}"]##*:}
		if [[ ${gn} == "${gname}" ]]; then
			members+=("${pri}")
		fi
	done
	return 0
}

# check "partner" settings conflict
function check_meg_group() {
	local -n prior_settings_ref=$1 meg_ref=$2
	local gr_name partner
	declare -a gr_names all_mems
	declare -A gr gm_values gr_stats

	bp_msg 3 "  prior setting conflict check"

	# get group list
	for gr_name in "${meg_ref[@]}"; do
		gr["${gr_name}"]=true
	done
	gr_names=("${!gr[@]}")

	# check groups one-by-one
	for gr_name in "${gr_names[@]}"; do
		all_mems=()
		prior_meg_members "${gr_name}" all_mems

		gm_values=()
		gr_stats=()
		for partner in "${all_mems[@]}"; do
			# if the partner in settings
			cn_name=${PRIORS[${partner}]%%:*}
			if is_array_key "${cn_name}" prior_settings_ref; then
				# in settings, use setting value
				gm_values["${prior_settings_ref[${cn_name}]}"]=true
				gr_stats["${partner}"]=${prior_settings_ref[${cn_name}]}
			else
				# use default settings
				gm_values[${CONFIGS[${cn_name}]}]=true
				gr_stats["${partner}"]=${CONFIGS[${cn_name}]}
			fi
		done
		# compare the count group members
		if [[ "${#gm_values[@]}" == "${#all_mems[@]}" ]]; then
			bp_msg 3 "    - group '${gr_name}' passed"
		else
			bp_msg 4 "    meg '${gr_name}' settings:"
			for partner in "${!gr_stats[@]}"; do
				bp_msg 4 "      ${partner}: ${gr_stats[${partner}]}"
			done
			pros_tag="${all_mems[*]}"
			exit_with_msg 34
		fi
	done
	return 0
}

# return code:
#  0 - arg                          an arg only
#  1 - <lid>sopara=arg              string | with built-in arg
#  2 - <lid>bopara                  bool   | with no arg
#  3 - <lid><plid>liga              liga   | with no arg
#  4 - <lid>sopara<space(s)>arg     string | will consume an arg
#  5 - <other-lid>para              alter  | not need an arg
#  6 - <other-lid>para<space(s)>arg alter  | will consume an arg
function check_para_type() {
	local lid=$1 current=$2 next=$3
	local -n para_ref=$4
	local para_name arg

	# echo "${lid} | ${current} | ${next}"
	# echo "lid:  $lid"
	# echo "curr: $current | next: $next"

	para_ref="${current}"

	if with_lid "${current}" "${lid}${lid}"; then
		# --current or ~~current like, liga
		return 3
	elif with_lid "${current}" "${lid}"; then
		# -current like, with lid
		if [[ "${current}" == *"${TAG_TRUE}" || "${current}" == *"${TAG_FALSE}" ]]; then
			# -current[+=] like, bool with trailing-tag
			return 2
		elif [[ "${current}" == *${OSEP}* ]]; then
			# -current=arg like, depends on arg
			para_name=${current%%"${OSEP}"*} # %% incase arg contains OSEP
			arg=${current#*"${OSEP}"}        # extract arg
			arg=${arg//[\'\"]/}              # remove quotes if exist
			if [[ ${arg} == true ]]; then
				# -currnt=true like, a bool
				para_ref="${para_name}${TAG_TRUE}"
				return 2
			elif [[ ${arg} == false ]]; then
				# -currnt=false like, a bool
				para_ref="${para_name}${TAG_FALSE}"
				return 2
			else
				# -current="right now" like, a string
				return 1
			fi
		elif with_lid "${next}" || [[ -z "${next}" ]]; then
			# -current -next like, or no next, a bool
			return 2
		else
			# -current arg like, next is an arg
			para_name=${current#"${lid}"}
			if [[ ${next} == true ]]; then
				# -current true like, a bool(next is a boolean value)
				para_ref="${para_name}${TAG_TRUE}"
				return 2
			elif [[ ${next} == false ]]; then
				# -current false like, a bool(next is a boolean value)
				para_ref="${para_name}${TAG_FALSE}"
				return 2
			else
				# -current "year of 1984" like, a string(next is not a boolean value)
				para_ref="${current}${OSEP}${next}"
				return 4
			fi
		fi
	elif with_lid "${current}"; then
		# match other lids
		if with_lid "${next}" || [[ -z "${next}" ]]; then
			# not consume an arg
			return 5
		else
			# consume an arg, leave it unchanged
			return 6
		fi
	else # not start with any lid, an arg
		return 0
	fi
}

function show_configs() {
	local para len_cn
	len_cn=$(
		for para in "${!CONFIGS[@]}"; do
			echo "${para}"
		done | wc -L
	)
	for para in "${!CONFIGS[@]}"; do
		# printf "%${len_cn}s|%s\n" "${CONFIGS[${para}]}" "${CONFIGS[${CONFIGS[${para}]}]}"
		printf "%${len_cn}s|%s\n" "${para}" "${CONFIGS[${para}]}"
	done
}

# usage:
# pf_str=$(serialize_assoc_array PFILTER)
function serialize_assoc_array() {
	local -n arr=$1
	local out=""
	for k in "${!arr[@]}"; do
		out+="${k}=${arr[$k]};"
	done
	echo "${out%;}"
}

# usage:
#   deserialize_assoc_array "$pf_str" PFILTER
deserialize_assoc_array() {
	local str="$1"
	local arr_name="$2"
	declare -gA "${arr_name}"
	local -n arr="${arr_name}"
	IFS=';' read -ra items <<<"${str}"
	for item in "${items[@]}"; do
		local key="${item%%=*}"
		local val="${item#*=}"
		arr["${key}"]="${val}"
	done
}

# show all paras
function show_paras() {
	echo PParas: >&2
	show_array BP_PParas
	echo Strings >&2
	show_array BP_Strings
	echo Bools: >&2
	show_array BP_Bools
}
# Tasks -------------------------------------------------------
# extract prior PSet parameters from command line then apply them
function process_prior_paras() {
	local para pri_name pri_arg pri_tag
	local -A new_settings=()
	local -a pset=() pliga=()

	declare pri_type pri_cname len_enum
	declare -A meg=()

	bp_msg 2 "Process prior paras"

	# extract other priors
	for para in "$@"; do
		with_lid "${para}" "${PRLID}" || continue
		pset+=("${BASH_REMATCH[0]}")
	done

	# validate types and length
	for para in "${pset[@]}"; do
		with_lid "${para}" "${PRLID}" || continue # should not fail, just in case
		pri_name=${para#"${PRLID}"}               # remove leading-id
		pri_name="${pri_name%%=*}"                # para-name, %% for value with '='
		pri_tag=${pri_name: -1}                   # may be tag of a bool
		pri_name=${pri_name%"${TAG_TRUE}"}        # remove trailing-tag
		pri_name=${pri_name%"${TAG_FALSE}"}       # remove trailing-tag
		pri_arg="${para#*=}"                      # arg
		pri_arg=${pri_arg//[\'\"]/}               # remove quotes

		# validate name
		is_array_key "${pri_name}" PRIORS || {
			pros_tag=${pri_name}
			exit_with_msg 31
		}

		# get schema
		pri_schema=${PRIORS["${pri_name}"]}

		pri_cname=${pri_schema%%:*}

		pri_schema=${pri_schema#*:} # remove pri_cname from pri_schema
		pri_type=${pri_schema%%:*}

		pri_schema=${pri_schema#*:} # remove pri_type from pri_schema
		len_enum=${pri_schema%:*}
		[[ -n ${len_enum} || ${pri_type} != 'resym' ]] || len_enum=1

		meg_name=${pri_schema##*:}
		[[ -z ${meg_name} ]] || meg["${pri_cname}"]=${meg_name}

		# echo "$pri_name | $pri_type | $pri_arg | $len_enum"
		validate_pset_name pri_name PRIORS
		if [[ ${pri_type} == 'bool' ]]; then
			pri_arg=${pri_tag}
		fi
		validate_pset_arg "${pri_name}" pri_arg "${pri_type}" PRIORS "${PRLID}" || true

		# parse bools
		if [[ ${pri_type} == 'bool' ]]; then
			pri_arg=$(parse_bool_tag "${pri_tag}")
			new_settings["${pri_cname}"]=${pri_arg}
		else
			new_settings["${pri_cname}"]=${pri_arg}
		fi
	done

	# check conflict
	# bp_msg 3 "check prior setting conflict"
	check_meg_group new_settings meg

	# apply prior settings
	for cname in "${!new_settings[@]}"; do
		CONFIGS["${cname}"]="${new_settings["${cname}"]}"
	done
}

# extract zone data from cml
function extract_zones() {
	local -n op_zone_ref=$1 pp_zone_ref=$2

	bp_msg 2 "Extract zones"

	shift 2
	local EZ_CML="$*" para

	# count ZSEP
	zsep_count=0
	for para in "$@"; do
		[[ ${para} != "${ZSEP}" ]] || ((zsep_count += 1))
	done

	if [[ ${zsep_count} -gt 1 ]]; then
		# duplicate ZSEPs
		exit_with_msg 3
	elif [[ "${EZ_CML}" == *[[:space:]]${ZSEP} ]]; then
		# OP_ZONE only with trailing ZSEP
		op_zone_ref=("$@")
		unset "op_zone_ref[$(($# - 1))]" # remove last para which is ZSEP
		return 0
	elif [[ ${EZ_CML} == ${ZSEP}[[:space:]]* ]]; then
		# PP_ZONE only with leading zone-sep
		pp_zone_ref=("$@")
		unset "pp_zone_ref[0]"            # remove first para which is ZSEP
		pp_zone_ref=("${pp_zone_ref[@]}") # re-index array after unset
		return 0
	elif [[ ${EZ_CML} == *[[:space:]]${ZSEP}[[:space:]]* ]]; then
		# two zones separated by a a ZONE_SEP
		local seen_zsep=false
		for para in "$@"; do
			if [[ ${seen_zsep} == false ]]; then
				if [[ ${para} == "${ZSEP}" ]]; then
					seen_zsep=true
				else
					op_zone_ref+=("${para}")
				fi
			else
				pp_zone_ref+=("${para}")
			fi
		done
	else # no ZONE_SEP, test first para
		if with_lid "${1:-}"; then
			# OP_ZONE only
			op_zone_ref=("$@")
		else
			# PP_ZONE only
			pp_zone_ref=("$@")
		fi
	fi
}

# function: extract paras with lid
#   extract oparas(ligas excluded) from command line
#   no para-validating
#   can be used to extrat prior/pset/user parameters
# extra:
#   replace space(s) between OParas/Psets and ARGs with OSEP
#   replace hyphen(s) in para-name with underscores
function extract_oparas() {
	local lid=$1
	local -n strings_ref=$2 bools_ref=$3 ligas_ref=$4 # for passing back PSets
	local -n CML=$5

	bp_msg 2 "  extract ${lid}oparas"

	local curr_para next_para extracted_para para_type i arg_consumed=false

	for i in "${!CML[@]}"; do
		if [[ "${arg_consumed}" == true ]]; then
			# para is an ARG of last para, skip
			arg_consumed=false
			continue
		fi

		curr_para="${CML[i]}"
		next_para="${CML[$((i + 1))]:-}" || next_para=""

		# parse paras
		para_type=0
		check_para_type "${lid}" "${curr_para}" "${next_para}" extracted_para || para_type=$?
		bp_msg 3 "    type: ${para_type} | extracted: ${extracted_para}"
		# bp_msg 3 "  extracted para:" "${extracted_para}"
		case "${para_type}" in
		1) strings_ref+=("${extracted_para}") ;;
		2) bools_ref+=("${extracted_para}") ;;
		3) ligas_ref+=("${extracted_para}") ;;
		4)
			strings_ref+=("${extracted_para}")
			arg_consumed=true
			;;
		5) ;; # matching other lid without arg, skip
		6)    # matching other lid followd by an arg, skip with a consumption signal
			arg_consumed=true ;;
		*) # a solitary arg found, parsing failed
			pros_tag="${curr_para}"
			exit_with_msg 24
			;;
		esac
	done
	return 0
}

# validate liga names, split into bools, parse values, load into result array
# used for both ligas of PSets and User OParas
function parse_ligas() {
	local lid=$1
	local -n ligas_ref2=$2

	local liga liga_name b_name b_nlen b_tag

	bp_msg 2 "  parse ${lid}ligas"

	for liga in "${ligas_ref2[@]}"; do
		# filter out non-liga paras
		with_lid "${liga}" "${lid}" || continue

		liga=${liga#"${lid}"}                    # remove lid
		b_tag=$(parse_bool_tag "${liga}")        # parse tag
		liga=${liga%["${TAG_TRUE}${TAG_FALSE}"]} # remove tag
		b_nlen=${liga%%[^[:digit:]]*}            # extract name length
		[[ -n "${b_nlen}" ]] || b_nlen=1         # default name length 1
		liga_name=${liga#"${b_nlen}"}            # remove length-integer

		bp_msg 3 "    liga:" "${liga} ${b_tag}"

		for ((start = 0; start < ${#liga_name}; start += b_nlen)); do
			b_name="${liga_name:${start}:${b_nlen}}"
			# for PSets, para-name should be verified
			if [[ ${lid} == "${PLID}${PLID}" ]]; then
				validate_pset_name b_name PSETS || true
				validate_pset_arg "${b_name}" b_tag 'bool' PSETS "${PLID}" || true
			else
				# for user paras, validate with bash variable naming convention
				validate_shell_variable_name b_name
			fi
			BP_Bools["${b_name}"]="${b_tag}"
			BP_OParas["${b_name}"]="${b_tag}"
		done
	done
}

function parse_bools() {
	local lid=$1
	local -n bs_ref=$2
	local bl b_name b_tag
	bp_msg 3 "  parse ${lid}bools"

	for bl in "${bs_ref[@]}"; do
		b_name=${bl#"${lid}"}               # remove lid
		b_tag=$(parse_bool_tag "${b_name}") # parse tag
		b_name=${b_name%"${TAG_TRUE}"}      # remove tag
		b_name=${b_name%"${TAG_FALSE}"}     # remove tag

		bp_msg -3 "    bool: " "${bl} | ${b_tag}"
		if [[ ${lid} == "${PLID}" ]]; then
			# PSets
			validate_pset_name b_name PSETS || true
			validate_pset_arg "${b_name}" b_tag 'bool' PSETS "${PLID}" || true
		else # User paras
			validate_shell_variable_name b_name
		fi

		BP_Bools["${b_name}"]="${b_tag}"
		BP_OParas["${b_name}"]="${b_tag}"
	done
}

function parse_strings() {
	local lid=$1
	local -n str_ref=$2
	local str s_name val

	bp_msg 3 "  parse ${lid}strings"

	for str in "${str_ref[@]}"; do
		# bp_msg 3 "    string: " "${str}"
		s_name=${str#"${lid}"}           # remove lid
		s_name=${s_name%%"${OSEP}"*}     # remove OSEP and value
		val="${str#*"${s_name}${OSEP}"}" # extract value
		val=${val//[\"\']/}              # remove quots if exist

		bp_msg 3 "    string:" "${s_name} | ${val:--}"
		# validate para-s_name
		if [[ ${lid} == "${PLID}" ]]; then
			# PSet paras
			# validate name
			validate_pset_name s_name PSETS || true
			# validate value with type and length
			validate_pset_arg "${s_name}" val 'string' PSETS "${PLID}" || true
		else
			# user parameter
			validate_shell_variable_name s_name
		fi

		BP_Strings["${s_name}"]="${val}"
		BP_OParas["${s_name}"]="${val}"
	done
}

# write PSets in to config array
function parse_oparas() {
	local lid=$1
	local -n strings_ref=$2 bools_ref=$3 ligas_ref=$4

	parse_ligas "${lid}${lid}" ligas_ref
	parse_bools "${lid}" bools_ref
	parse_strings "${lid}" strings_ref
}

function apply_setup() {
	local ps
	# merge PSets
	for ps in "${!BP_Strings[@]}"; do
		BP_OParas["${ps}"]="${BP_Strings[${ps}]}"
	done
	for ps in "${!BP_Bools[@]}"; do
		BP_OParas["${ps}"]="${BP_Bools[${ps}]}"
	done

	# apply settings to CONFIGS
	for ps in "${!BP_OParas[@]}"; do
		CONFIGS["${PSETS["${ps}"]%%:*}"]="${BP_OParas["${ps}"]}"
	done
}

function parse_pparas() {
	BP_PParas=("$@")
	bp_msg 3 "  PParas parsed"
}

function create_variables() {
	local var
	bp_msg 2 "Option parameters:"
	# bools
	for var in "${!BP_Bools[@]}"; do
		declare -g "${var}"="${BP_Bools["${var}"]}"
		bp_msg 2 "  ${var}"="${BP_Bools["${var}"]}"
	done
	# strings
	for var in "${!BP_Strings[@]}"; do
		declare -g "${var}"="${BP_Strings[${var}]}"
		bp_msg 2 "  ${var}"="${BP_Strings[${var}]}"
	done
}

function output_ppara_array() {
	# if ppara array name specified, create a name reference
	[[ ${#BP_PParas[@]} -ne 0 ]] || return 0
	bp_msg 2 "Positional parameters in '${CONFIGS["ppara_array_name"]}()'"
	if [[ ${CONFIGS["ppara_array_name"]} != "BP_PParas" ]]; then
		local ppara_an="${CONFIGS["ppara_array_name"]}"
		declare -gn "${ppara_an}"=BP_PParas
	fi
	for i in "${!BP_PParas[@]}"; do
		bp_msg 2 "  ${BP_PParas[i]}"
	done
}

function output_eval() {
	# output vars
	# show_array BP_OParas >&2
	local pi
	for pi in "${!BP_OParas[@]}"; do
		echo "${pi}='${BP_OParas[${pi}]}'"
	done
	for pi in "${!BP_PParas[@]}"; do
		echo "ppara_${pi}='${BP_PParas[${pi}]}'"
	done
}

function output_json() {
	# output $BP_OParas in JSON using a single jq -n call
	command -v jq >/dev/null 2>&1 || exit_with_msg 47

	local para val idx=0
	local -a jq_args=()
	local expr='{}'

	# helper: valid number check (no leading zeros except '0')
	is_number() {
		[[ $1 =~ ^-?(0|[1-9][0-9]*)(\.[0-9]+)?$ ]]
	}

	for para in "${!BP_OParas[@]}"; do
		val=${BP_OParas[$para]}
		idx=$((idx + 1))
		jq_args+=(--arg "k${idx}" "$para")
		if [[ "$val" == "true" || "$val" == "false" ]]; then
			# boolean literal
			jq_args+=(--argjson "v${idx}" "$val")
		elif is_number "$val"; then
			# numeric literal (integers or decimals without leading zeros)
			jq_args+=(--argjson "v${idx}" "$val")
		else
			# force string
			jq_args+=(--arg "v${idx}" "$val")
		fi
		expr+=" + {(\$k${idx}): \$v${idx}}"
	done

	# Emit positional parameters as a JSON array under the key 'PParas'
	if [[ ${#BP_PParas[@]} -gt 0 ]]; then
		local pparas_json
		pparas_json=$(printf '%s\n' "${BP_PParas[@]}" | jq -R -s -c 'split("\n")[:-1]')
		idx=$((idx + 1))
		jq_args+=(--arg "k${idx}" "PParas")
		jq_args+=(--argjson "v${idx}" "${pparas_json}")
		expr+=" + {(\$k${idx}): \$v${idx}}"
	fi

	jq -n "${jq_args[@]}" "$expr"
}

# Helper: type check and alias application
pf_validate_para() {
	local para=$1 pf_type=$2 pf_data=$3

	# echo para: $para
	local val=${BP_OParas[${para}]}

	case ${pf_type} in
	enum)
		[[ ${verbose} -ge 4 ]] && printf "    \e[33m%-10s\e[0;2m | type: %-6s | value: %s\n\e[0m" "${para}:" "enum" "${pf_data}" >&2
		# split enum string safely into array
		local IFS='|'
		read -ra enum_list <<<"$pf_data"
		# if not in enum list, parsing failed
		if ! in_array "${val}" enum_list; then
			pros_tag="${para}=${val}"
			pros_tag2="${pf_data//|/\/}"
			exit_with_msg 40
		fi
		;;
	bool)
		[[ ${verbose} -ge 4 ]] && printf "    \e[33m%-10s\e[0;2m | type: %-6s | value: %s\n\e[0m" "${para}:" "bool" "${val}" >&2
		if [[ ${val} != true && ${val} != false ]]; then
			pros_tag="${para}=${val}"
			pros_tag2="true/false"
			exit_with_msg 40
		fi
		;;
	string)
		[[ ${verbose} -ge 4 ]] && printf "    \e[33m%-10s\e[0;2m | type: %-6s | value: %s\n\e[0m" "${para}:" "string" "${val}" >&2
		if [[ ${val} == true || ${val} == false ]]; then
			pros_tag="${para}=${val}"
			pros_tag2="a string but got a bool"
			exit_with_msg 40
		fi
		;;
	alias)
		[[ ${verbose} -ge 4 ]] && printf "    \e[33m%-10s\e[0;2m | type: %-6s | value: %s\n\e[0m" "${para}:" "alias" "${pf_data}" >&2
		# alias: pf_data holds the target name
		# if target para supplied, skip alias check
		# if not, set tartet para with alias para value; set alias_used for caller reference.
		# this ensure when both alias and target supplied, target win
		if ! is_array_key "${pf_data}" BP_OParas; then
			# target para not supplied, apply alias
			target_pf_type=${PFILTER["${pf_data}"]%%:*}
			# validate if alias value matching target type
			BP_OParas["${pf_data}"]="${val}"
			pf_validate_para "${pf_data}" "${target_pf_type}" "${val}"
			# set target
			if [[ ${target_pf_type} == "bool" ]]; then
				BP_Bools["${pf_data}"]="${val}"
			else # string/enum
				BP_Strings["${pf_data}"]="${val}"
			fi
			alias_used["${para}"]=true
		fi
		# unset alias para in any cases
		unset "BP_OParas[${para}]"
		is_array_key "${para}" BP_Bools && unset "BP_Bools[${para}]"
		is_array_key "${para}" BP_Strings && unset "BP_Strings[${para}]"
		;;
	*)
		pros_tag="${para}=${val}"
		pros_tag2="${pf_type}"
		exit_with_msg 41
		;;
	esac
	return 0
}

# Helper: check mutual-exclusion groups for given owner (value-holder)
pf_meg_check() {
	bp_msg 3 "  check mutual-exclusion value groups"
	local -n PFILTER_ref=$1

	# get all meg names
	declare -A meg_groups=()
	local meg_field member_meg member_megs

	for member in "${!PFILTER_ref[@]}"; do
		meg_field=${PFILTER_ref[${member}]##*:} # extract meg field
		if [[ -n ${meg_field} ]]; then
			# if a para belongs to multiple meg, separate meg names with vertical line '|', e.g.
			# "meg1|meg2", the para will be checked in all the meg it belongs to.
			for meg in ${meg_field//|/ }; do
				meg_groups["${meg}"]=true
			done
		fi
	done
	local meg_names=("${!meg_groups[@]}")

	for meg in "${meg_names[@]}"; do
		bp_msg 3 "    checking meg:" "${meg}"
		declare -a meg_members=()
		declare -a meg_values=()

		# find members in the same meg
		for member in "${!PFILTER_ref[@]}"; do
			member_meg=${PFILTER_ref[${member}]##*:}
			# safely split meg names into array
			local IFS='|'
			read -ra member_megs <<<"${member_meg}" # may belong to multiple megs
			if in_array "${meg}" member_megs; then
				meg_members+=("${member}")
			fi
		done

		# collect values of members in this meg
		for member in "${meg_members[@]}"; do
			if is_array_key "${member}" BP_OParas; then
				bp_msg 4 "      member" "'${member}'"
				meg_values+=("${BP_OParas[${member}]}")
			fi
		done
		if [[ ${#meg_values[@]} -ne $(printf '%s\n' "${meg_values[@]}" | sort -u | wc -l) ]]; then
			pros_tag="${meg}"
			pros_tag2="${meg_members[*]}"
			exit_with_msg 37
		fi
		bp_msg 3 "      - PASSED"
	done
}

# two ways to pass PFILTER in:
#   PFILTER name reference - for an associative array, used in source mode
#   serialized PFILTER - a string, used for all modes, e.g.:
#         "gender=enum:male|female:;h=alias:help:;movie1=string::gmv;PARA-FILTER=::;"
# a valid PFILTER must include a memeber whose key is "PARA-FILTER"

function validate_pfilter() {
	local pf_name pf pt p_filter
	local al_type al_data al_meg
	local al_type2 al_data2

	pf_name="${CONFIGS[${PSETS["pf"]%%:*}]}"
	# if [[ "${pf_name}" == "no_pf" ]]; then
	# 	bp_msg 4 "no PFILTER supplied."
	# 	return 1
	# fi

	if validate_shell_variable_name pf_name true; then
		# may be an associative array name reference
		if pf=$(declare -p "${pf_name}" 2>/dev/null); then
			if [[ ${pf} == "declare -A "* ]]; then
				# an associative array, check id
				if is_array_key "${PFILTER_ID}" "${pf_name}"; then
					# id check passed
					declare -n "p_filter=${pf_name}"
				else
					pros_tag="no identifier key 'PARA-FILTER'"
					exit_with_msg 49
				fi
			else
				pros_tag="not an associative array"
				exit_with_msg 49
			fi
		else
			pros_tag="checking failed."
			exit_with_msg 49
		fi
	else # not valid shell variable, try deserialized PFILTER
		local -A p_filter
		deserialize_assoc_array "${pf_name}" p_filter
		# might be serialized associative array
		if ! is_array_key "${PFILTER_ID}" p_filter; then
			pros_tag="no identifier key 'PARA-FILTER'"
			exit_with_msg 49
		fi
	fi

	# remove PFILTER_ID
	unset "pfilter[${PFILTER_ID}]"

	# validate key/target name and replace exceptions for PFILTER entries
	for pf in "${!p_filter[@]}"; do
		# validate keys
		pt="${pf}"
		validate_shell_variable_name pt
		PFILTER["${pt}"]="${p_filter[${pf}]}"

		# validate target name
		extract_pfilter_entry "${pt}" al_type al_data al_meg
		if [[ ${al_type} == "alias" ]]; then
			al_data0="${al_data}"
			validate_shell_variable_name al_data
			PFILTER["${pt}"]=${PFILTER["${pt}"]/"${al_data0}"/"${al_data}"}
		fi
	done

	# check data integrity of PFILTER
	# alias has target
	# target has solo alias
	# enum required data field
	declare -A aliases=()
	local al_type al_data al_meg
	for pf in "${!PFILTER[@]}"; do
		extract_pfilter_entry "${pf}" al_type al_data al_meg
		case ${al_type} in
		alias)
			# al_data0="${al_data}"
			# validate_shell_variable_name al_data
			# PFILTER["${pf}"]=${PFILTER["${pf}"]/"${al_data0}"/"${al_data}"}
			is_array_key "${al_data}" PFILTER || {
				pros_tag="${pf}"
				pros_tag2="${al_data}"
				exit_with_msg 43
			}
			if [[ -z ${aliases["${al_data}"]:-} ]]; then
				aliases["${al_data}"]=1
			else
				((aliases["${al_data}"] += 1))
			fi
			extract_pfilter_entry "${al_data}" al_type2 al_data2 al_meg
			if [[ ${al_type2} == "alias" ]]; then
				# chaining alias found
				pros_tag="${pf}"
				exit_with_msg 51
			fi
			;;
		enum)
			[[ -n "${al_data}" ]] || {
				pros_tag="${pf}"
				exit_with_msg 48
			}
			;;
		*) ;;
		esac
	done

	# check multiple aliases
	for pf in "${!aliases[@]}"; do
		if [[ "${aliases[${pf}]}" -gt 1 ]]; then
			pros_tag="${pf}"
			pros_tag2="${aliases[${pf}]}"
			exit_with_msg 50
		fi
	done
}

function pf_assign_defaults() {
	local para=$1 pf_type=$2 pf_data=$3
	# for string/bool type, use data field
	# for enum type, use first enum as default value
	case "${pf_type}" in
	bool | string)
		if ! is_array_key "${para}" BP_OParas; then
			# not supplied
			if [[ -n ${pf_data} ]]; then
				# default value specified in PFILTER
				BP_OParas["${para}"]="${pf_data}"
				if [[ ${pf_type} == "bool" ]]; then
					BP_Bools["${para}"]="${pf_data}"
				else
					BP_Strings["${para}"]="${pf_data}"
				fi
			else # not supplied && no default value, parsing failed
				pros_tag="${para}"
				exit_with_msg 46
			fi
		fi
		[[ ${verbose} -ge 4 ]] && printf "    \e[33m%-10s\e[0;2m | type: %-6s | value: %s\n\e[0m" "${para}:" "${pf_type}" "${BP_OParas[${para}]:-undefined}" >&2
		;;
	enum)
		if ! is_array_key "${para}" BP_OParas; then
			# set default value to the first enum if not set by user
			default_enum=${pf_data%%'|'*}
			BP_OParas["${para}"]="${default_enum}"
			# enum type is treated as string in BP_OParas(true|false should be set as Booleans)
			BP_Strings["${para}"]="${default_enum}"
			[[ ${verbose} -ge 4 ]] && printf "    \e[33m%-10s\e[0;2m | type: %-6s | value: %s\n\e[0m" "${para}:" "enum" "${BP_OParas[${para}]:-undefined}" >&2
		fi
		;;
	alias)
		# check if the target para exits in PFILTER
		if ! is_array_key "${pf_data}" PFILTER; then
			# no target in PFILTER, parsing failed
			pros_tag="${para}"
			pros_tag2="${pf_data}"
			exit_with_msg 43
		fi
		# alias para is used to supply value to its target
		# if data/meg defined in alias para, they will be ignored.
		# if target para supplied, ignore alias; other wise set target with alias value
		# this ensure when both alias and target supplied, target win
		if ! is_array_key "${pf_data}" BP_PParas; then
			# target not supplied, set by default value
			local target_type target_data target_meg
			extract_pfilter_entry "${pf_data}" target_type target_data target_meg
			pf_assign_defaults "${pf_data}" "${target_type}" "${target_data}"

			# BP_OParas["${pf_data}"]="${BP_OParas[${para}]}"
			# if is_array_key "${para}" BP_Bools; then
			# 	BP_Bools["${pf_data}"]="${BP_Bools[$para]}"
			# else
			# 	BP_Strings["${pf_data}"]="${BP_Strings[${para}]}"
			# fi
			# alias_used["${para}"]=true
		fi

		# # alias transfered or target supplied, clear alias from parsing result
		# unset "BP_OParas[${para}]"
		# is_array_key "${para}" BP_Bools && unset "BP_Bools[${para}]"
		# is_array_key "${para}" BP_String && unset "BP_Strings[${para}]"
		;;
	*)
		pros_tag="${para}"
		pros_tag2="${pf_type}"
		exit_with_msg 42
		;;
	esac
	return 0
}

function extract_pfilter_entry() {
	local p_key=$1 p_schema
	local -n p_type=$2 p_data=$3 p_meg=$4

	p_schema=${PFILTER[${p_key}]}
	p_type=${p_schema%%:*}  # extract type
	p_schema=${p_schema#*:} # remove type
	p_data=${p_schema%%:*}  # extract data
	p_meg=${p_schema#*:}    # extract meg

	# echo "key: ${p_key} | type: ${p_type} | meg: ${p_meg}"
}

# declare -A PFILTER=(
# 	["para_name"]="type:data:meg"
# 	["help"]="bool::"
# 	["h"]="alias:help:"
# 	["dependency"]="string:node:"
# 	["gender"]="enum:male|female:"
# 	["role_a"]="string:admin:grole" # role_* should be different
# 	["role_b"]="string::grole"
# 	["role_c"]="string::grole"
# )
#
# para_filter value schema: "filed1:field2:fibraceeld3"
#   field 1: type, bool/string/enum/alias
#   field 2: data, depends on type:
#            bool: default value
#            string: default value
#            enum: enums separated by vertical line '|'
#            alias: target para-name
#        for bool/string, if date field not specified, no default value will be set;
#        for enum data field is required, otherwise parsing will fail; if specified, the first
#        enum will be used as default value;
#        for alias para, data field should be the alias target, and the alias will inherit
#        type/data/meg of the target; if data/meg defined in alias para, it will be ignored.
#   field 3: mutual-exclusion value group(meg) name
#        this field is optional, if specified, paras in the same group should not be assigned
#        with the same value, otherwise conflict happens and parsing will fail.
#        meg is designed for scenarios like role settings where multiple para valuesare mutually
#        exclusive but do not have a fixed set of enums.
#        In the example above, role_a, role_b and role_c are in the same meg "grole", they can
#        take any string value but should not be assigned with the same value.
#        for alias para, meg should be defined on the alias target, and the alias will inherit
#        the meg of the target; if meg defined in alias para, it will be ignored
#        when a para belongs to multiple meg, separate meg names with vertical line '|', e.g.
#        "meg1|meg2", the para will be checked in all the meg it belongs to.
#
# apply para_filter to validate user parameters/aliases
# meg(mutual-exclusion group) identified paras should not be assigned with the same value
# parsing will failed if meg conflict found.
# assign default first ensure command line parameters overridden defaults in PFILTER
function apply_para_filter() {
	bp_msg 2 "Apply para filter"

	local AMF="${CONFIGS[${PSETS["amf"]%%:*}]}"
	bp_msg 4 "  PFILTER-ID: ${PFILTER_ID} | AMF: ${AMF}"

	declare -A PFILTER
	local rtn=0
	validate_pfilter || rtn=$?

	if [[ ${rtn} -ne 0 ]]; then
		bp_msg 3 "    PFILTER should be passed as an associative array in source-mode; "
		bp_msg 3 "    or a string of serialized associative array in all modes"
		# echo "mode: ${CONFIGS["${PSETS["run"]%%:*}"]}"
		return 0
	fi

	local para pf_type pf_data pf_meg

	bp_msg 3 "  check paras with pfilter"
	for para in "${!BP_OParas[@]}"; do
		if [[ ${AMF} == true ]]; then
			# all parameter must be defined in PFILTER
			if ! is_array_key "${para}" PFILTER; then
				# non-defined parameter found, parsing failed
				pros_tag="${para}"
				exit_with_msg 45
			fi
		fi
		if is_array_key "${para}" PFILTER; then
			extract_pfilter_entry "${para}" pf_type pf_data pf_meg
			# type check; handle aliases
			pf_validate_para "${para}" "${pf_type}" "${pf_data}"
		else # not defined in PFILTER, let it be
			:
		fi
	done

	bp_msg 3 "  assign default values if not supplied"
	for para in "${!PFILTER[@]}"; do
		extract_pfilter_entry "${para}" pf_type pf_data pf_meg
		pf_assign_defaults "${para}" "${pf_type}" "${pf_data}"
	done

	# check meg conflict
	pf_meg_check PFILTER
}

# main function -----------------------------------------------
function bosparse() {

	local_script_path="$(realpath "${BASH_SOURCE[0]}")"
	local_script_dir="${local_script_path%\/*}"
	# local_script_name="${local_script_path##*\/}"

	declare -A CONFIGS CONSTS PSETS PALIAS
	declare -A PRIORS LIDS EXCEPTIONS EXIT_MSG
	declare -a CONFIG_PARAS RESYMS
	declare -A alias_used=()

	definitions \
		CONFIGS \
		CONSTS \
		PSETS \
		PALIAS \
		PRIORS \
		LIDS \
		RESYMS \
		EXCEPTIONS \
		EXIT_MSG

	declare -n PRLID='LIDS["prior"]'
	declare -n PLID='LIDS["plid"]'
	declare -n OLID='LIDS["olid"]'
	declare -n OSEP='CONFIGS["oa_sep"]'
	declare -n ZSEP='CONFIGS["zn_sep"]'
	declare -n TAG_TRUE='CONFIGS["trailing_tag_true"]'
	declare -n TAG_FALSE='CONFIGS["trailing_tag_false"]'
	declare -n TAG_DEFAULT='CONFIGS["trailing_tag_default"]'
	declare -n RUN_MODE='CONFIGS["run_mode"]'
	declare -n NO_PFILTER='CONSTS["NO_PFILTER"]'
	declare -n PFILTER_ID='CONSTS["PFILTER_ID"]'

	# echo ---------------------
	# echo $*

	update_verbose
	bp_msg 3 "Command line: " "$*"
	bp_msg -2 "verbose: " "${verbose}"

	# treat empty "$@"
	[[ $# -eq 0 || $* == '--' || $* == "${ZSEP}" ]] && exit_with_msg 2

	bp_msg 2 "Parse Priors"
	process_prior_paras "$@" || exit_with_msg 23
	update_verbose

	[[ ${verbose} -ge 3 ]] && show_configs

	# disassemble command line parameters
	declare -a op_zone=() pp_zone=()
	extract_zones op_zone pp_zone "$@"

	bp_msg 4 "op zone:" "${op_zone[*]}"
	bp_msg 4 "pp zone:" "${pp_zone[*]}"

	# Psets
	declare -a strings=() bools=() ligas=()
	bp_msg 2 "Extract PSets"
	extract_oparas "${PLID}" strings bools ligas op_zone || true

	bp_msg 3 "Parse psets"
	parse_oparas "${PLID}" strings bools ligas

	bp_msg 3 "apply settings"
	apply_setup
	update_verbose

	[[ ${verbose} -gt 2 ]] && show_configs

	# parsing user parameter parsing
	BP_OParas=()
	BP_Bools=()
	BP_Strings=()
	alias_used=()
	strings=()
	bools=()
	ligas=()
	bp_msg 2 "Extract user-paras"
	extract_oparas "${OLID}" strings bools ligas op_zone || true

	bp_msg 2 "Parse user-paras"
	parse_oparas "${OLID}" strings bools ligas || true

	# apply user-defined para-filter
	# echo  "- ${CONFIGS[${PSETS["pf"]%%:*}]}"
	# echo  "- ${NO_PFILTER}"
	[[ "${CONFIGS[${PSETS["pf"]%%:*}]}" == "${NO_PFILTER}" ]] || apply_para_filter

	bp_msg 2 "Parse user-pparas"
	parse_pparas "${pp_zone[@]}"

	# prepare parsing result on user requirement
	bp_msg 2 "Output parsing result"
	# the user set ~run/mode (PSet) will be respect; Otherwise autodetect
	# echo "script name: ${BASH_SOURCE[0]} | $0"
	if [[ ${RUN_MODE} == "auto" ]]; then # auto is the default value
		# autodetect
		if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
			bp_msg 3 "  sourced, output as variables by default"
			RUN_MODE="source"
		else
			if [[ ${CONFIGS[${PSETS["j"]%%:*}]} == true ]]; then
				bp_msg 3 "not sourced, use 'capture' mode as 'json' specified."
				RUN_MODE="capture"
			else
				bp_msg 3 "not sourced, use 'eval' mode as default"
				RUN_MODE="eval"
			fi
		fi
	fi

	case ${RUN_MODE} in
	source)
		bp_msg 3 "  Output as variables."
		create_variables
		output_ppara_array
		;;
	eval)
		bp_msg 3 "  Output as eval statements."
		output_eval
		;;
	capture)
		bp_msg 3 "  Output as JSON."
		output_json
		;;
	*) ;;
	esac
	bp_msg 3 "Mission complete"
}
# echo $(realpath "${BASH_SOURCE[0]}")
# echo $0
if [[ $(basename "$(realpath "${BASH_SOURCE[0]}")") == $(basename "$0") ]]; then
	bosparse "$@"
fi
