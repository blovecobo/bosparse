#!/usr/bin/env bash

# bosparse - a bash script to parse parameters for bash scripts
# author: blovecob
# version: 0.1.0
# platform: bash 4.4+
# usage:
#   - source bosparse
#     bosparse [option parameters] -- [positional parameters]
#   - eval $(bosparse [option -arameters] -- [positional parameters])
#   - json=$(bosparse ~j [option parameters] -- [positional parameters])
#
#
set -euo pipefail

function definitions() {
	local -n BOSPARSE_CONFIGS_ref=$1
	local -n CONFIG_PARAS_ref=$2
	local -n PSETS_ref=$3
	local -n PSET_ALIAS_ref=$4
	local -n PRIORS_ref=$5
	local -n LIDS_ref=$6
	local -n RESERVED_SYMBOLS_ref=$7
	local -n EXCEPTIONS_ref=$8
	local -n EXIT_MSG_ref=$9

	# BOSPARSE_PARAMETER_NAME
	# running and output
	local run="run_mode"
	local j="output_as_json"

	# array for results
	local oan="opara_array_name"
	local ban="bool_array_name"
	local san="string_array_name"
	local pan="ppara_array_name"

	# parsing-aid sympbols
	local prior="prior_lid"
	local plid="pset_lid"
	local olid="opara_lid"
	local tt="trailing_tag_true"
	local tf="trailing_tag_false"
	local td="trailing_tag_default"
	local zs="zn_sep"
	local os="oa_sep"

	# runtime display control
	local q="quiet"
	local s="standard"
	local e="extra"
	local d="debug"
	local t="trace"

	CONFIG_PARAS_ref=(
		"${run}"
		"${j}"
		"${oan}"
		"${ban}"
		"${san}"
		"${pan}"
		"${prior}"
		"${plid}"
		"${olid}"
		"${tt}"
		"${tf}"
		"${td}"
		"${zs}"
		"${os}"
		"${q}"
		"${s}"
		"${e}"
		"${d}"
		"${t}"
	)

	# bosparse default configs
	BOSPARSE_CONFIGS_ref=(
		# running mode
		["${run}"]="auto" # ~run/mode, maybe "source", "eval" or "capture"
		["${j}"]=false

		# parse results
		["${oan}"]=BP_OParas  # ~oan,  name of array to store OParas
		["${ban}"]=BP_Bools   # ~ban,  name of array to store Bool-OParas
		["${san}"]=BP_Strings # ~san,  name of array to store String-OParas
		["${pan}"]=BP_PParas  # ~pan,  name of array to store PParas

		# runtime display control
		["${q}"]=false # ~q output level, 0
		["${s}"]=true  # ~s output level, 1(default)
		["${e}"]=false # ~e output level, 2
		["${d}"]=false # ~d output level, 3
		["${t}"]=false # ~t output level, 4

		# Prior PSets
		# Parsing-aid symbols
		["${prior}"]='~~~' # ~~~prior,  leading id sighn for prior- psets and seps
		["${plid}"]='~'    # ~~~plid,   leading id sign for setting-parameters
		["${olid}"]='-'    # ~~~olid,   leading id sign for user-parameters

		# seps
		["${zs}"]='--' # ~~~zs, seperator between VAR_ZONE and PP_ZONE
		["${os}"]='='  # ~~~os, seperator beteen para-names and their args

		# trailing tags
		["${tt}"]='+'  # ~~~tt, tag character for 'true'
		["${tf}"]='-'  # ~~~tf, tag character for 'false'
		["${td}"]=true # ~~~td, defaut tag value(when tag omitted)
	)

	# parsing result arrays
	local o_array=${BOSPARSE_CONFIGS_ref["${oan}"]}
	local b_array=${BOSPARSE_CONFIGS_ref["${ban}"]}
	local s_array=${BOSPARSE_CONFIGS_ref["${san}"]}
	local p_array=${BOSPARSE_CONFIGS_ref["${pan}"]}
	declare -gA "${o_array}" "${b_array}" "${s_array}"
	declare -ga "${p_array}"

	LIDS_ref=(
		["prior"]="${BOSPARSE_CONFIGS_ref[${prior}]}"
		["plid"]="${BOSPARSE_CONFIGS_ref[${plid}]}"
		["olid"]="${BOSPARSE_CONFIGS_ref[${olid}]}"
	)

	PSETS_ref=(
		["run"]="${run}:e:auto|source|eval|capture"
		# ["mode"]="${e}:e:auto|source|eval|capture"

		["j"]="${j}:b"
		# ["json"]="${j}:b"

		["oan"]="${oan}:s"
		["ban"]="${ban}:s"
		["san"]="${san}:s"
		["pan"]="${pan}:s"

		["q"]="${q}:b"
		["s"]="${s}:b"
		["e"]="${e}:b"
		["d"]="${d}:b"
		["t"]="${t}:b"
	)

	PSET_ALIAS_ref=(
		["json"]="j"
		["mode"]="run"
		["quiet"]="q"
		["standard"]="s"
		["extra"]="e"
		["debug"]="d"
		["track"]="q"
	)
	# Prior PSets config structure:
	#   field1: config name of entries in CONFIGS | string
	#	field2: prior type | a letter
	#	        may be boolean(b), string(s), character(c) or enum(e)
	#   field3: for type-c: symbol length | integer, use default(1) if not set
	#           for type-e: emum | enum values separated by '|'
	#   field4: mevg name | string(mutual-exclusion value group)
	#           for configs not permitted to share same value
	# all four fields needed even if it's empty
	PRIORS_ref=(
		["prior"]="${prior}:c:3:"
		["plid"]="${plid}:c::glid"
		["olid"]="${olid}:c::glid"
		["zs"]="${zs}:c:2:"
		["os"]="${os}:c::"
		["tt"]="${tt}:c::gtagv"
		["tf"]="${tf}:c::gtagv"
		["td"]="${td}:e:true|false:"
	)

	# reserve symbols for LIDs and SEPs
	RESERVED_SYMBOLS_ref=(
		'~'
		'-'
		'='
		'_'
		'+'
		'&'
		'%'
		'@'
	)

	# exceptions for bash variable naming convention, replacing hyphens with underscores
	EXCEPTIONS_ref=(['-']="_")

	pros_tag=""
	pros_tag2=""
	EXIT_MSG_ref=(
		["0"]="Parsing succeeded."
		["1"]="Parsing failed."
		["2"]="No parameter supplied."
		["3"]="Only one ZONE_SEP '--' required."

		["23"]="Prior parse error."
		["24"]="A solitary ARG '\${pros_tag}' found."
		["25"]="Invalid PSet parameter: '\${pros_tag}'"
		["26"]="Parameter name '\${pros_tag}' invalid, it should be a valid shell variable name."
		["31"]="Invalid Prior name: '\${pros_tag}'"
		["32"]="PSet '\${pros_tag}' mismatch the length."
		["33"]="The parameter name '\${pros_tag}' contains invalid character(s)."
		["34"]="Prior settings conflict between '\${pros_tag}'"
		["35"]="Invalid PSet setting: '\${pros_tag}', ARG should be '\${pros_tag2}'"
		["36"]="Prameter '\${pros_tag}' in liga '\${pros_tag2}' not valid."
		["38"]="value of '\${pros_tag}' should not be empty."
		["39"]="PSet '\${pros_tag}' should be '\${pros_tag2}'"
	)
}
# Primitives --------------------------------------------------
#
# check if the parameter is a array key
function is_array_key() {
	local key=$1
	local -n arr_ref=${2:-} # array might not available
	local k
	for k in "${!arr_ref[@]}"; do
		[[ ${k} != "${key}" ]] || return 0
	done
	return 1
}

# chck if a string is a array member
function in_array() {
	local str=$1
	local -n arr_ref=${2:-} # array might not available
	local mem
	for mem in "${arr_ref[@]}"; do
		[[ ${mem} != "${str}" ]] || return 0
	done
	return 1
}

# calculate the max length of members of an array
# usage max_lengh_array_members arrayref max_lenthref "$extra_len"
function max_length_array_members() {
	local -n arr="$1" l_max="$2"
	local extra="${3:-0}" # optional

	l_max=$(($(
		for member in "${arr[@]}"; do
			echo "${member}"
		done | wc -L
	) + extra))
}

function show_array() {
	local -n target_arr=$1
	local separator=${2:--}
	local key lmax=0
	declare -a keys_array
	# build keys array
	keys_array=("${!target_arr[@]}")

	max_length_array_members keys_array lmax 2
	for key in "${!target_arr[@]}"; do
		printf "%${lmax}s %s %s \n" "${key}" "${separator}" "${target_arr[${key}]}"
	done
}

# function: bp_msg
# feature:
#   show msg by msg_level
#   a nective msg_level number means show msgs in one-line(no CR)
function bp_msg() {

	local msg_level=${1:-0} title=${2:-} content=${3:-}

	# nothing to show
	[[ "${verbose}" == 0 || -z "${verbose}" ]] && return 0

	if [[ "${msg_level}" -lt 0 ]]; then
		in_one_line=true
		msg_level=$((0 - msg_level))
	fi

	# local IFS=$'\n'
	if [[ "${verbose}" -ge "${msg_level}" ]]; then
		if [[ "${in_one_line:-false}" == true ]]; then
			echo -e "\e[33m${title}\e[0;2m ${content}\e[0m" >&2
		else
			[[ -n "${title}" ]] && echo -e "\e[33m${title}\e[0m" >&2
			[[ -n "${content}" ]] && echo -e "\e[2m${content}\e[0m" >&2
		fi
	fi
	return 0
}

# Expand simple ${varname} templates in messages for safe printing.
function template_expand() {
	local template=$1
	# Replace known placeholders safely. Add more as needed.
	template=${template//\$\{pros_tag\}/"${pros_tag}"}
	template=${template//\$\{pros_tag2\}/"${pros_tag2}"}
	printf '%s' "${template}"
}

# exit with a specific exit code and a revelant message
function exit_with_msg() {
	local exit_code=$1
	local additional_msg=${2:-}
	local last_command=${3:-}
	local msg

	if [[ "${verbose:-0}" -gt 0 ]]; then
		msg="${EXIT_MSG[${exit_code}]}"

		# expand any template variables (e.g., ${pros_tag}) in message safely
		local _msg_expanded
		_msg_expanded=$(template_expand "$msg")
		printf '\e[33merror:\e[0m %s\n' "$_msg_expanded" >&2
		if [[ -n "${additional_msg}" ]]; then
			_msg_expanded=$(template_expand "$additional_msg")
			printf '\e[2m        %s\e[0m\n' "${_msg_expanded}" >&2
		fi
		if [[ -n "${last_command}" ]]; then
			# Run the additional command in a subshell to avoid unsafe eval in current shell
			bash -c -- "${last_command}" >&2
		fi
	fi
	exit "${exit_code}"
}

# bash variable naming convention
# hyphens are permitted if they are not at the very beginning
# replacing hyphens by underscores
# trailing-tag should be removed in advance, or will be interpreted as underscore
function validate_shell_variable_name() {
	local -n var_name_ref=$1

	[[ "${var_name_ref}" =~ ^[a-zA-Z_][a-zA-Z0-9_-]*$ ]] || {
		pros_tag="${var_name_ref}"
		exit_with_msg 26
	}
	# replace exceptions
	if [[ $# -eq 2 ]]; then
		local -n except_ref=$2
		for orig in "${!except_ref[@]}"; do
			var_name_ref=${var_name_ref//"${orig}"/"${except_ref[${orig}]}"}
		done
	fi
	return 0
}

# Helper functions --------------------------------------------
#
# test if a string contains leading-id
#   if lid specified, test with it
#   or try all lids
function with_lid() {
	local para=$1 lid=${2:-}
	if [[ -n ${lid} ]]; then
		[[ ${para} == "${lid}" ]] && return 0
		[[ ${para} =~ ^${lid}[^${lid:0:1}].*$ ]] && return 0
		return 1
	else
		# try all lids
		for lid in "${LIDS[@]}"; do
			[[ ${para} == ${lid}* ]] && return 0
		done
		return 1
	fi
}

# check if a string consist of members of a RESYMS
function in_resyms() {
	local sample=$1
	local mb

	for mb in "${RESYMS[@]}"; do
		mb=${mb//[\'\"]/}                           # remove quots
		[[ "${sample}" =~ ^[${mb}]+$ ]] && return 0 # matched
	done
	return 1 # match failed
}

# turn output settings to verbose
function update_verbose() {
	# trace > debug > extra > standard > quiet

	[[ ${CONFIGS["quiet"]} == true ]] && {
		verbose=0
		__QUIET=true
	}
	[[ ${CONFIGS["standard"]} == true ]] && {
		verbose=1
		_STANDARD=true
	}
	[[ ${CONFIGS["extra"]} == true ]] && {
		verbose=2
		_EXTRA=true
	}
	[[ ${CONFIGS["debug"]} == true ]] && {
		verbose=3
		__DEBUG=true
	}
	[[ ${CONFIGS["trace"]} == true ]] && {
		verbose=4
		__TRACE=true
	}
	[[ -n ${verbose:-1} ]] || {
		verbose=1
		_STANDARD=true
	}
	return 0
}

# check possible trailing tag for a para-name
function parse_bool_tag() {
	local para=$1
	local tag=${para: -1}

	case "${tag}" in
	"${TAG_TRUE}") echo true ;;
	"${TAG_FALSE}") echo false ;;
	*) echo "${TAG_DEFAULT}" ;;
	esac
}

function pset_alias_key() {
	local alias=$1
	if is_array_key "${alias}" alias_used; then
		echo "${alias_used[${alias}]}"
	else
		echo "${alias}"
	fi
	return 0
}

# validate a PSet parameter name, exit with error message if test failed
function validate_pset_name() {
	local -n pname_ref=$1
	local -n psets=$2

	# check aliase
	is_array_key "${pname_ref}" PALIAS && {
		alias_used[${PALIAS[${pname_ref}]}]="${pname_ref}"
		pname_ref="${PALIAS[${pname_ref}]}"
	}
	pros_tag="${pname_ref}"
	is_array_key "${pname_ref}" psets || exit_with_msg 25
	return 0
}

function match_pset_type() {
	local para=$1 type_ref=$2
	local type_defined

	type_defined="${PSETS[${para}]#*:}"   # remove config name
	type_defined="${type_defined%%:*}"    # remvoe length/enum and mevg name if exist
	type_defined=${type_defined//[\"\']/} # remove quots if exist
	[[ "${type_defined}" == "${type_ref}" ]] || {
		pros_tag="${para}"
		pros_tag2="${type_defined}"
		exit_with_msg 39
	}
}

# validate a PSet value with its type and length/enum
function validate_pset_arg() {
	local para_name=$1 para_type=$3 lid=$5
	local -n para_arg=$2 para_sets=$4

	# echo "$para_name | $para_arg | $para_type | ${para_sets[*]}"
	local pset_schema=${para_sets[${para_name}]}
	# local pset_value=${pset_schema%%:*}    # extract value
	pset_schema=${pset_schema#*:}          # remove value
	local pset_type=${pset_schema%%:*}     # extract type
	pset_schema=${pset_schema#*:}          # remove type
	local pset_len_enum=${pset_schema%%:*} # extract length/enum
	[[ -n ${pset_len_enum} || ${pset_type} != 'c' ]] || pset_len_enum=1

	[[ "${para_type}" == "${pset_type}" || ${pset_type} == 'e' ]] || {
		case "${pset_type}" in
		b) pros_tag2="true/false" ;;
		s) pros_tag2="a string" ;;
		c) pros_tag2="RESYMS" ;;
		*) ;;
		esac
		pros_tag="${para_name}"
		exit_with_msg 39
	}

	pset_property_check "${lid}" "${para_name}" "${pset_type}" para_arg "${pset_len_enum}"
}

# parse a liga, validate para-name, passing back result
# usable for all ligas
function parse_liga_para() {
	local liga=$1
	local -n paras_ref=$2
	local -n settings_ref=$3

	local tag para_len start para_name

	tag=$(parse_bool_tag "${liga}")

	liga=${liga%"${TAG_TRUE}"}      # remove true tag if exist
	liga=${liga%"${TAG_FALSE}"}     # remove false tag if exist
	para_len=${liga%%[^[:digit:]]*} # extract para length
	liga=${liga#"${para_len}"}      # pure liga name left
	[[ -n "${para_len}" ]] || para_len=1

	for ((start = 0; start < ${#liga}; start += para_len)); do
		para_name="${liga:${start}:${para_len}}"
		is_array_key "${para_name}" paras_ref || {
			pros_tag="${para_name}"
			pros_tag2="${liga}"
			exit_with_msg 36
		}
		settings_ref["${paras_ref[${para_name}]%%:*}"]=${tag}
	done
}

# check if a pset para value matching type and length
# exit with error message if test failed
function pset_property_check() {
	local lid=$1 pname=$2 ptype=$3 ple=$5
	local -n parg=$4
	local pset_alias

	# echo "$lid | ${pname} | ${ptype} | ${parg} | ${ple}"
	# validate value
	case ${ptype} in
	e) # enum, check if value in enums
		declare -a enmu=()
		# mapfile -t enum < <(echo "${ple}" | cut -d \| -f1- --out=$'\n')
		enum=(${ple//\|/ })
		if ! in_array "${parg}" enum; then
			pset_alias=$(pset_alias_key "${pname}")
			pros_tag="${lid}${pset_alias}=${parg}"
			pros_tag2="${ple//\|/\/}"
			exit_with_msg 35
		fi
		;;
	c) # check if in resyms, length
		pset_alias=$(pset_alias_key "${pname}")
		pros_tag="${lid}${pset_alias}=${parg}"
		pros_tag2="in RESYMS(${RESYMS[*]})"
		# prior settings should be in RESYMS
		in_resyms "${parg}" || exit_with_msg 35
		[[ "${ple}" == "${#parg}" ]] || exit_with_msg 32
		;;
	s) # string, should be a valid shell variable name after replacing hyphens with underscores
		validate_shell_variable_name parg EXCEPTIONS || exit_with_msg 33
		# should not be empty
		[[ -n "${parg}" ]] || {
			pros_tag="${pname}"
			exit_with_msg 38
		}
		;;
	*) ;; # skipped for others
	esac
	bp_msg -3 "    - properties valid:" "'${pname}'"
	return 0
}

# get all priors in a mevg
function prior_mevg_members() {
	local gname=$1
	local -n members=$2
	local gn

	for pri in "${!PRIORS[@]}"; do
		gn=${PRIORS["${pri}"]##*:}
		if [[ ${gn} == "${gname}" ]]; then
			members+=("${pri}")
		fi
	done
	return 0
}

# check "partner" settings conflict
function check_mev_group() {
	local -n prior_settings_ref=$1 mevg_ref=$2
	local gr_name partner
	declare -a gr_names all_mems
	declare -A gr gm_values gr_stats

	bp_msg 3 "  prior setting conflict check"

	# get group list
	for gr_name in "${mevg_ref[@]}"; do
		gr["${gr_name}"]=true
	done
	gr_names=("${!gr[@]}")

	# check groups one-by-one
	for gr_name in "${gr_names[@]}"; do
		all_mems=()
		prior_mevg_members "${gr_name}" all_mems

		gm_values=()
		gr_stats=()
		for partner in "${all_mems[@]}"; do
			# if the partner in settings
			cn_name=${PRIORS[${partner}]%%:*}
			if is_array_key "${cn_name}" prior_settings_ref; then
				# in settings, use setting value
				gm_values["${prior_settings_ref[${cn_name}]}"]=true
				gr_stats["${partner}"]=${prior_settings_ref[${cn_name}]}
			else
				# use default settings
				gm_values[${CONFIGS[${cn_name}]}]=true
				gr_stats["${partner}"]=${CONFIGS[${cn_name}]}
			fi
		done
		# compare the count group members
		if [[ "${#gm_values[@]}" == "${#all_mems[@]}" ]]; then
			bp_msg 3 "    - group '${gr_name}' passed"
		else
			bp_msg 4 "    mevp '${gr_name}' settings:"
			for partner in "${!gr_stats[@]}"; do
				bp_msg 4 "      ${partner}: ${gr_stats[${partner}]}"
			done
			pros_tag="${all_mems[*]}"
			exit_with_msg 34
		fi
	done
	return 0
}

# return code:
#  0 - arg                           an arg only
#  1 - <plid>sopara=arg              string | with built-in arg
#  2 - <plid>bopara                  bool   | with no arg
#  3 - <plid><plid>liga              liga   | with no arg
#  4 - <plid>sopara<space(s)>arg     string | will consume an arg
#  5 - <other-lid>para               alter  | not need an arg
#  6 - <other-lid>para<space(s)>arg  alter  | will consume an arg
function check_para_type() {
	local lid=$1 current=$2 next=$3
	local -n para_ref=$4

	# echo "${lid} | ${current} | ${next}"
	# echo "lid:  $lid"
	# echo "curr: $current | next: $next"

	para_ref="${current}"

	if with_lid "${current}" "${lid}${lid}"; then
		# --current or ~~current like, liga
		return 3
	elif with_lid "${current}" "${lid}"; then
		# -current like, with lid
		if [[ ${current} =~ (.*[${TAG_TRUE}$)|(.*${TAG_FALSE}]$) ]]; then
			# -current[+=] like, bool with trailing-tag
			return 2
		elif [[ "${current}" == *${OSEP}* ]]; then
			# -current=arg like, depends on arg
			para_name=${current%%"${OSEP}"*} # %% incase arg contains OSEP
			arg=${current#*"${OSEP}"}        # extract arg
			arg=${arg//[\'\"]/}              # remove quots if exist
			if [[ ${arg} == true ]]; then
				# -currnt=true like, a bool
				para_ref="${para_name}${TAG_TRUE}"
				return 2
			elif [[ ${arg} == false ]]; then
				# -currnt=false like, a bool
				para_ref="${para_name}${TAG_FALSE}"
				return 2
			else
				# -current="right now" like, a string
				return 1
			fi
		elif with_lid "${next}" || [[ -z "${next}" ]]; then
			# -current -next like, or no next, a bool
			return 2
		else
			# -current arg like, next is an arg
			if [[ ${next} == true || ${next} == false ]]; then
				# -current true like, a bool(next is a boolean value)
				para_ref="${para_name}${TAG_FALSE}"
				return 2
			else
				# -current "year of 1984" like, a string(next is not a boolean value)
				para_ref="${current}${OSEP}${next}"
				return 4
			fi
		fi
	elif with_lid "${current}"; then
		# match other lids
		if with_lid "${next}" || [[ -z "${next}" ]]; then
			# not consume an arg
			return 5
		else
			# consume an arg, leave it unchanged
			return 6
		fi
	else # not start with any lid, an arg
		return 0
	fi
}

function show_configs() {
	local para
	len_cn=$(
		for para in "${CONFIG_PARAS[@]}"; do
			echo "${para}"
		done | wc -L
	)
	for i in "${!CONFIG_PARAS[@]}"; do
		printf "%${len_cn}s|%s\n" "${CONFIG_PARAS[i]}" "${CONFIGS[${CONFIG_PARAS[${i}]}]}"
	done
}

# Tasks -------------------------------------------------------
# extract prior PSet parameters from command line then apply them
function process_prior_paras() {
	local para pri_name pri_arg pri_tag
	local -A new_settings=()
	local -a pset=() pliga=()

	declare pri_type pri_cname len_enum pair
	declare -A mevg=()

	bp_msg 2 "Process prior paras"

	# extract other priors
	for para in "$@"; do
		with_lid "${para}" "${PRLID}" || continue
		pset+=("${BASH_REMATCH[0]}")
	done

	# validate types and length
	for para in "${pset[@]}"; do
		with_lid "${para}" "${PRLID}" || continue # should not fail, just in case
		pri_name=${para#"${PRLID}"}               # remove leading-id
		pri_name="${pri_name%%=*}"                # para-name, %% for value with '='
		pri_tag=${pri_name: -1}                   # may be tag of a bool
		pri_name=${pri_name%"${TAG_TRUE}"}        # remove trailing-tag
		pri_name=${pri_name%"${TAG_FALSE}"}       # remove trailing-tag
		pri_arg="${para#*=}"                      # arg
		pri_arg=${pri_arg//[\'\"]/}               # remove quots

		# validate name
		is_array_key "${pri_name}" PRIORS || {
			pros_tag=${pri_name}
			exit_with_msg 31
		}

		# get schema
		pri_schema=${PRIORS["${pri_name}"]}

		pri_cname=${pri_schema%%:*}

		pri_schema=${pri_schema#*:} # remove pri_cname from pri_schema
		pri_type=${pri_schema%%:*}

		pri_schema=${pri_schema#*:} # remove pri_type from pri_schema
		len_enum=${pri_schema%:*}
		[[ -n ${len_enum} || ${pri_type} != 'c' ]] || len_enum=1

		mev_name=${pri_schema##*:}
		[[ -z ${mev_name} ]] || mevg["${pri_cname}"]=${mev_name}

		# echo "$pri_name | $pri_type | $pri_arg | $len_enum"
		validate_pset_name pri_name PRIORS
		if [[ ${pri_type} == 'b' ]]; then
			pri_arg=${pri_tag}
		fi
		validate_pset_arg "${pri_name}" pri_arg "${pri_type}" PRIORS ${PRLID} || true

		# parse bools
		if [[ ${pri_type} == 'b' ]]; then
			pri_arg=$(parse_bool_tag "${pri_tag}")
			new_settings["${pri_cname}"]=${pri_arg}
		else
			new_settings["${pri_cname}"]=${pri_arg}
		fi
	done

	# check confilict
	# bp_msg 3 "check prior setting conflict"
	check_mev_group new_settings mevg

	# apply prior settings
	for cname in "${!new_settings[@]}"; do
		CONFIGS["${cname}"]="${new_settings["${cname}"]}"
	done
}

# extract zone data from cml
function extract_zones() {
	local -n op_zone_ref=$1 pp_zone_ref=$2

	bp_msg 2 "Extract zones"

	shift 2
	local EZ_CML="$*" para

	# count ZSEP
	zsep_count=0
	for para in "$@"; do
		[[ ${para} != "${ZSEP}" ]] || ((zsep_count += 1))
	done

	if [[ ${zsep_count} -gt 1 ]]; then
		# duplicate ZSEPs
		exit_with_msg 3
	elif [[ "${EZ_CML}" == *[[:space:]]${ZSEP} ]]; then
		# OP_ZONE only with trailing ZSEP
		op_zone_ref=("$@")
		unset "op_zone_ref[$(($# - 1))]" # remove last para which is ZSEP
		return 0
	elif [[ ${EZ_CML} == ${ZSEP}[[:space:]]* ]]; then
		# PP_ZONE only with leading zone-sep
		pp_zone_ref=("$@")
		unset "pp_zone_ref[0]"            # remove first para which is ZSEP
		pp_zone_ref=("${pp_zone_ref[@]}") # re-index array after unset
		return 0
	elif [[ ${EZ_CML} == *[[:space:]]${ZSEP}[[:space:]]* ]]; then
		# two zones separated bya a ZONE_SEP
		local seen_zsep=false
		for para in "$@"; do
			if [[ ${seen_zsep} == false ]]; then
				if [[ ${para} == "${ZSEP}" ]]; then
					seen_zsep=true
				else
					op_zone_ref+=("${para}")
				fi
			else
				pp_zone_ref+=("${para}")
			fi
		done
	else # no ZONE_SEP, test first para
		if with_lid "${1:-}"; then
			# OP_ZONE only
			op_zone_ref=("$@")
		else
			# PP_ZONE only
			pp_zone_ref=("$@")
		fi
	fi
}

# function: extract paras with lid
#   extract oparas(ligas excluded) from command line
#   no para-validating
#   can be used to extrat prior/pset/user parameters
# extra:
#   replace space(s) between OParas/Psets and ARGs with OSEP
#   replace hyphen(s) in para-name with underscores
function extract_oparas() {
	local lid=$1
	local -n strings_ref=$2 bools_ref=$3 ligas_ref=$4 # for passing back PSets
	local -n CML=$5

	bp_msg 2 "extract ${lid}oparas"

	local curr_para next_para extracted_para para_type i arg_consumed=false

	for i in "${!CML[@]}"; do
		if [[ "${arg_consumed}" == true ]]; then
			# para is an ARG of last para, skip
			arg_consumed=false
			continue
		fi

		curr_para="${CML[i]}"
		next_para="${CML[$((i + 1))]:-}" || next_para=""

		# parse paras
		para_type=0
		check_para_type "${lid}" "${curr_para}" "${next_para}" extracted_para || para_type=$?
		bp_msg 3 "type: ${para_type} | extracted: ${extracted_para}"
		bp_msg 3 "  extracted para:" "${extracted_para}"
		case "${para_type}" in
		1) strings_ref+=("${extracted_para}") ;;
		2) bools_ref+=("${extracted_para}") ;;
		3) ligas_ref+=("${extracted_para}") ;;
		4)
			strings_ref+=("${extracted_para}")
			arg_consumed=true
			;;
		5) ;; # matching other lid without arg, skip
		6)    # matching other lid followd by an arg, skip with a consumption signal
			arg_consumed=true ;;
		*) # a solitary arg found, parsing failed
			pros_tag="${curr_para}"
			exit_with_msg 24
			;;
		esac
	done
}

# validate liga nmaes, split into bools, parse values, load into result array
# used for both ligas of PSets and User OParas
function parse_ligas() {
	local lid=$1
	local -n ligas_ref2=$2

	local liga liga_name b_name b_nlen b_tag

	bp_msg 2 "parse ${lid}ligas"

	for liga in "${ligas_ref2[@]}"; do
		# filter out non-liga paras
		with_lid "${liga}" "${lid}" || continue

		bp_msg 3 "  liga:" "${liga}"

		liga=${liga#"${lid}"}                    # remove lid
		b_tag=$(parse_bool_tag "${liga}")        # parse tag
		liga=${liga%["${TAG_TRUE}${TAG_FALSE}"]} # remove tag
		b_nlen=${liga%%[^[:digit:]]*}            # extract name length
		[[ -n "${b_nlen}" ]] || b_nlen=1         # default name length 1
		liga_name=${liga#"${b_nlen}"}            # remove length-integer

		for ((start = 0; start < ${#liga_name}; start += b_nlen)); do
			b_name="${liga_name:${start}:${b_nlen}}"
			# for PSets, para-name should be verified
			if [[ ${lid} == "${PLID}${PLID}" ]]; then
				validate_pset_name b_name PSETS || true
				validate_pset_arg "${b_name}" b_tag 'b' PSETS "${PLID}" || true
			else
				# for user paras, validate with bash variable naming convention
				validate_shell_variable_name b_name EXCEPTIONS
			fi
			BP_Bools["${b_name}"]="${b_tag}"
			BP_OParas["${b_name}"]="${b_tag}"
		done
	done
}

function parse_bools() {
	local lid=$1
	local -n bs_ref=$2
	local bl b_name b_tag
	bp_msg 3 "parse ${lid}bools"

	for bl in "${bs_ref[@]}"; do
		bp_msg -3 "  bool: " "${bl}"
		b_name=${bl#"${lid}"}               # remove lid
		b_tag=$(parse_bool_tag "${b_name}") # parse tag
		b_name=${b_name%"${TAG_TRUE}"}      # remove tag
		b_name=${b_name%"${TAG_FALSE}"}     # remove tag

		if [[ ${lid} == "${PLID}" ]]; then
			# PSets
			validate_pset_name b_name PSETS || true
			validate_pset_arg "${b_name}" b_tag 'b' PSETS "${PLID}" || true
		else # User paras
			validate_shell_variable_name b_name EXCEPTIONS
		fi

		BP_Bools["${b_name}"]="${b_tag}"
		BP_OParas["${b_name}"]="${b_tag}"
	done
}

function parse_strings() {
	local lid=$1
	local -n str_ref=$2
	local str s_name val

	bp_msg 3 "parse ${lid}strings"

	for str in "${str_ref[@]}"; do
		bp_msg 3 "  string: " "${str}"
		s_name=${str#"${lid}"}           # remove lid
		s_name=${s_name%%"${OSEP}"*}     # remove OSEP and value
		val="${str#*"${s_name}${OSEP}"}" # extract value
		val=${val//[\"\']/}              # remove quots if exist

		# validate para-s_name
		if [[ ${lid} == "${PLID}" ]]; then
			# PSet paras
			# validate name
			validate_pset_name s_name PSETS || true
			# validate value with type and length
			validate_pset_arg "${s_name}" val 's' PSETS "${PLID}" || true
		else
			# user parameter
			validate_shell_variable_name s_name EXCEPTIONS
		fi

		BP_Strings["${s_name}"]="${val}"
		BP_OParas["${s_name}"]="${val}"
	done
}

# write PSets in to config array
function parse_oparas() {
	local lid=$1
	local -n strings_ref=$2 bools_ref=$3 ligas_ref=$4

	parse_ligas "${lid}${lid}" ligas_ref
	parse_bools "${lid}" bools_ref
	parse_strings "${lid}" strings_ref
}

function apply_setup() {
	local ps
	# merge PSets
	for ps in "${!BP_Strings[@]}"; do
		BP_OParas["${ps}"]="${BP_Strings[${ps}]}"
	done
	for ps in "${!BP_Bools[@]}"; do
		BP_OParas["${ps}"]="${BP_Bools[${ps}]}"
	done

	# appliy settings to CONFIGS
	for ps in "${!BP_OParas[@]}"; do
		CONFIGS["${PSETS["${ps}"]%%:*}"]="${BP_OParas["${ps}"]}"
	done
}

function parse_pparas() {
	BP_PParas=("$@")
	bp_msg 3 "pparas parsed"
}

function create_variables() {
	local var
	bp_msg 2 "Option parameters:"
	# bools
	for var in "${!BP_Bools[@]}"; do
		declare -g "${var}"="${BP_Bools["${var}"]}"
		bp_msg 2 "  ${var}"="${BP_Bools["${var}"]}"
	done
	# strings
	for var in "${!BP_Strings[@]}"; do
		declare -g "${var}"="${BP_Strings[${var}]}"
		bp_msg 2 "  ${var}"="${BP_Strings[${var}]}"
	done
}

function output_ppara_array() {
	# if ppara array name specified, create a name reference
	[[ ${#BP_PParas[@]} -ne 0 ]] || return 0
	bp_msg 2 "Positional parameters in '${CONFIGS["ppara_array_name"]}()'"
	if [[ ${CONFIGS["ppara_array_name"]} != "BP_PParas" ]]; then
		local ppara_an="${CONFIGS["ppara_array_name"]}"
		declare -gn "${ppara_an}"=BP_PParas
	fi
	for i in "${!BP_PParas[@]}"; do
		bp_msg 2 "  ${BP_PParas[i]}"
	done
}

function output_eval() {
	# output vars
	# show_array BP_OParas >&2
	local pi
	for pi in "${!BP_OParas[@]}"; do
		echo "${pi}='${BP_OParas[${pi}]}'"
	done
	for pi in "${!BP_PParas[@]}"; do
		echo "ppara_${pi}='${BP_PParas[${pi}]}'"
	done
}

function output_json() {
	# output $BP_OParas() in JSON using a single jq -n call (no -s)
	local para val idx=0
	local -a jq_args=()
	local expr='{}'

	for para in "${!BP_OParas[@]}"; do
		val=${BP_OParas[$para]}
		idx=$((idx + 1))
		jq_args+=(--arg "k${idx}" "$para")
		if [[ "$val" == "true" || "$val" == "false" || "$val" =~ ^-?[0-9]+(\.[0-9]+)?$ ]]; then
			jq_args+=(--argjson "v${idx}" "$val")
		else
			jq_args+=(--arg "v${idx}" "$val")
		fi
		expr+=" + {(\$k${idx}): \$v${idx}}"
	done

	# Emit positional parameters as a JSON array under the key 'PParas'
	if [[ ${#BP_PParas[@]} -gt 0 ]]; then
		# build a JSON array safely from BP_PParas using jq -R -s -c
		local pparas_json
		pparas_json=$(printf '%s\n' "${BP_PParas[@]}" | jq -R -s -c 'split("\n")[:-1]')
		idx=$((idx + 1))
		jq_args+=(--arg "k${idx}" "PParas")
		jq_args+=(--argjson "v${idx}" "${pparas_json}")
		expr+=" + {(\$k${idx}): \$v${idx}}"
	fi

	jq -n "${jq_args[@]}" "$expr"
}

# main function -----------------------------------------------
function bosparse() {

	local_script_path="$(realpath "${BASH_SOURCE[0]}")"
	local_script_dir="${local_script_path%\/*}"
	# local_script_name="${local_script_path##*\/}"

	declare -A CONFIGS EXCEPTIONS EXIT_MSG
	declare -A PRIORS PSETS LIDS PALIAS
	declare -a CONFIG_PARAS RESYMS
	declare -A alias_used=()

	definitions \
		CONFIGS \
		CONFIG_PARAS \
		PSETS \
		PALIAS \
		PRIORS \
		LIDS \
		RESYMS \
		EXCEPTIONS \
		EXIT_MSG

	declare -n PRLID='LIDS["prior"]'
	declare -n PLID='LIDS["plid"]'
	declare -n OLID='LIDS["olid"]'
	declare -n ZSEP='CONFIGS["zn_sep"]'
	declare -n OSEP='CONFIGS["oa_sep"]'
	declare -n TAG_TRUE='CONFIGS["trailing_tag_true"]'
	declare -n TAG_FALSE='CONFIGS["trailing_tag_false"]'
	declare -n TAG_DEFAULT='CONFIGS["trailing_tag_default"]'
	declare -n RUN_MODE='CONFIGS["run_mode"]'

	# echo ---------------------
	# echo $*

	update_verbose
	bp_msg 2 "Command line: " "$*"
	bp_msg -2 "verbose: " "${verbose}"

	# treat empty "$@"
	[[ $# -eq 0 || $* == '--' || $* == "${ZSEP}" ]] && exit_with_msg 2

	bp_msg 2 "Parse Priors"
	process_prior_paras "$@" || exit_with_msg 23
	update_verbose

	# show_configs

	# disassemble command line parameters
	declare -a op_zone=() pp_zone=()
	extract_zones op_zone pp_zone "$@"

	bp_msg 4 "op zone:" "${op_zone[*]}"
	bp_msg 4 "pp zone:" "${pp_zone[*]}"

	# Psets
	declare -a strings=() bools=() ligas=()
	bp_msg 2 "Extract PSets"
	extract_oparas "${PLID}" strings bools ligas op_zone || true

	bp_msg 3 "Parse psets"
	parse_oparas "${PLID}" strings bools ligas

	bp_msg 3 "apply settings"
	apply_setup
	update_verbose

	[[ ${verbose} -gt 2 ]] && show_configs

	# parsing user parameter parsing
	BP_OParas=()
	BP_Bools=()
	BP_Strings=()
	strings=()
	bools=()
	ligas=()
	bp_msg 2 "Extract user-paras"
	extract_oparas "${OLID}" strings bools ligas op_zone || true

	bp_msg 2 "Parse user-paras"
	parse_oparas "${OLID}" strings bools ligas || true

	bp_msg 2 "Parse user-pparas"
	parse_pparas "${pp_zone[@]}"

	# prepare parsing result on user requirement
	bp_msg 2 "Output parsing result"
	# the user set ~run/mode (PSet) will be respect; Otherwise autodetect
	echo "script name: ${BASH_SOURCE[0]} | $0"
	if [[ ${RUN_MODE} == "auto" ]]; then # auto is the default value
		# autodetect
		if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
			bp_msg 2 "sourced in another script, output as variables by default"
			RUN_MODE="source"
		else
			if [[ ${CONFIGS[${PSETS["j"]%%:*}]} == true ]]; then
				bp_msg 2 "not sourced, use 'capture' mode as 'json' specified."
				RUN_MODE="capture"
			else
				bp_msg 2 "not sourced, use 'eval' mode as default"
				RUN_MODE="eval"
			fi
		fi
	fi

	case ${RUN_MODE} in
	source)
		bp_msg 3 "Output as variables."
		create_variables
		output_ppara_array
		;;
	eval)
		bp_msg 3 "Output as eval statements."
		output_eval
		;;
	capture)
		bp_msg 3 "Output as JSON."
		output_json
		;;
	*) ;;
	esac
	bp_msg 3 "Mission complete"
}
# echo $(realpath "${BASH_SOURCE[0]}")
# echo $0
if [[ $(basename "$(realpath "${BASH_SOURCE[0]}")") == $(basename "$0") ]]; then
	bosparse "$@"
fi
